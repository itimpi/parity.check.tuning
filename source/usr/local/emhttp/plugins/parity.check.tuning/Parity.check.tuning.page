Menu="Scheduler:1b"
Title="Parity Check Tuning"
Tag="gear"
---
<?PHP
/* Copyright 2019-2025, Dave Walker (itimpi).
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License version 2,
 * as published by the Free Software Foundation.
 *'
 * Limetech is given explicit permission to use this code in any way they like.
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * Useful site for checking php sytax: https://phphub.net/linter/
 * Useful site for validating HTML: https://codeshack.io/html-validator/
 */
?>
<!--
########################
Parity.check.tuning.page
########################
-->
<?
require_once "/usr/local/emhttp/plugins/parity.check.tuning/parity.check.tuning.helpers.php";
  
// Multi-language support
$translations = file_exists("/usr/local/emhttp/webGui/include/Translations.php");
if (!$translations):  eval('?>'.parse_file("/usr/local/emhttp/plugins/parity.check.tuning/Parity.check.tuning.page"));
else:
?>
<script>


//  Preset field values on initial load that do not change if input values change.

function initialiseParityTuning(form) {

<? parityTuningLoggerTesting("---initialise:  ParityTuning page being displayed---");?>
  
  // Force options that require parity to be present to the 'No' valueset to 
  // or Cumulative at Unraid level as then plugin cannot handle increments
  // ... and then also hide them
  <? if ($parityTuningNoParity || $parityTuningCumulative):?>
	form.parityTuningRecon.value = "0";
	form.parityTuningClear.value = "0";
  <?else:?>
  	document.getElementById('parityTuningClearDisplay').style.display  = "inline";
	document.getElementById('parityTuningReconDisplay').style.display  = "inline";
  <?endif;?>

  // Force options that cannot be used if Cumulative set to Yes to 'No'
  <? if ($parityTuningCumulative):?>  
    // Give warning if user has just activated Cumulative mode at Unraid level
	if	(form.parityTuningScheduled.value == "1") {
		swal({title: "_(Incompatible options)_",
			  text: "_(The Unraid Cumulative Parity Check setting must be set to No if you want to use the Parity Check Tuning plugin to run Array operations in increments)_",
			  icon: "Error"});
	}
	form.parityTuningScheduled.value="0";
	form.parityTuningAutomatic.value="0";
	form.parityTuningManual.value="0";
  <?else:?>
	document.getElementById('parityTuningScheduledDisplay').style.display  = "inline";
	document.getElementById('parityTuningAutomaticDisplay').style.display  = "inline";
	document.getElementById('parityTuningManualDisplay').style.display  = "inline";
  <?endif;?>
  
  // Backup option cannot be used if plugin not installed
  <? if ($parityTuningNoBackup):?>
     form.parityTuningBackup.value = "0";
  <?else:?>
  	 document.getElementById('parityTuningBackupDisplay').style.display  = "inline";
  <?endif;?>

  // Docker option cannot be used if docker not enabled
  <? if (!$parityTuningDockerEnabled):?> 
    form.parityTuningDocker.value = "0";
	document.getElementById('parityTuningDockerDisplay').style.display  = "none";
  <?elseif ($parityTuningExperimental):?> 
      // and even then if it is only currently in experimental mode
	  document.getElementById('parityTuningDockerDisplay').style.display  = "inline";
  <?endif;?>
  
  // Now the fields that vary according to other specific field values
  presetParityTuning(form)
}

// Fields to be enabled/disabled or hidden/shown as appropriate and any forced values for fields

function presetParityTuning(form) {
  if ((form.parityTuningManual.value == '0')
  && (form.parityTuningScheduled.value == '0')
  && (form.parityTuningAutomatic.value == '0')
  && (form.parityTuningClear.value == '0')
  && (form.parityTuningRecon.value == '0')) {
    document.getElementById('parityTuningIncrementDisplay').style.display = "none"; 
  } else {
    document.getElementById('parityTuningIncrementDisplay').style.display = "inline"; 
    // Hide show options that depend on frequency selection
    switch (form.parityTuningFrequency.value) {
	  case "1": // custom
		document.getElementById('parityTuningCustomResume').style.display = "inline"; 
		document.getElementById('parityTuningCustomPause').style.display  = "inline";
		// document.getElementById('parityTuningDayResume').style.display  = "none";
		// document.getElementById('parityTuningTimeResume').style.display = "none";
		// document.getElementById('parityTuningDayPause').style.display   =  "none";
		document.getElementById('parityTuningPauseDisplay').style.display  = "none";
	    document.getElementById('parityTuningResumeDisplay').style.display  = "none";
		break;
	  case "2": // weekly
	  case "0": // daily)
		document.getElementById('parityTuningCustomResume').style.display = "none";
		document.getElementById('parityTuningCustomPause').style.display  = "none";
		document.getElementById('parityTuningResumeDisplay').style.display = "inline";
		document.getElementById('parityTuningPauseDisplay').style.display  = "inline";
		if (form.parityTuningFrequency.value == '0') {
			document.getElementById('parityTuningDayResume').style.display = "none";
			document.getElementById('parityTuningDayPause').style.display  = "none";
		} else {
			document.getElementById('parityTuningDayResume').style.display = "inline";
			document.getElementById('parityTuningDayPause').style.display  = "inline";
		}
		break;
	}	 
  }

  // Hide Notifications for background tasks unless being monitored
  document.getElementById('parityTuningBackgroundDisplay').style.display  = 
  ((form.parityTuningMover.value == "0") && (form.parityTuningBackup.value == "0")) ? "none":"inline";

  // Hide docker containers selection unless docker option set to yes 
  document.getElementById('parityTuningContainersDisplay').style.display = (form.parityTuningDocker.value == '0' ? "none" : "inline");
 
  // Hide heat temperature setting unless monitoring heat for pause/resume 
  document.getElementById('parityTuningHeatDisplay').style.display = 
  (form.parityTuningHeat.value == "0" ? "none" : "inline");

  // Hide crtial heat temperature shutdown setting unless heat for shutdown
  document.getElementById('parityTuningCriticalDisplay').style.display = (form.parityTuningHeatShutdown.value == "0" ? "none" : "inline");
  
  switch (form.parityTuningLogging.value) {
	case "0": // Basic
	case "1": // Debug
		// Only allow logging to flash drive in Testing Mode
		form.parityTuningLogTarget.value = "0";	
		form.parityTuningLogTarget.style.display = "none";
		break;
  	case "2": // Testing
		form.parityTuningLogTarget.style.display = "inline";
		break;
  }
}

function confirmReconYes(form) {
    if (form.parityTuningRecon.value == "1") {
        swal({title: "_(This might affect array integrity)_",
              text: "_(Pausing an operation that is building parity or rebuilding a failed disk has a level of risk as your array is not back in a protected state until this operation completes successfully)_.   _(Only enable this option if the operation is adversely affecting system use and you are not worried about the extra time that will elapse before the system is once again in a protected state)_.",
              icon: "Warning"});
    }
}

function confirmClearYes(form) {
    if (form.parityTuningClear.value == "1") {
        swal({title: "_(Do you really want this)_?",
              text: "_(Pausing an disk Clear operation extends the time before the disk is successfully added to the array and becomes ready for formatting and then used for data storage)_.  _(On most systems a disk Clear operation does not adversely affect performance so typically this option is left disabled)_.",
              icon: "Warning"});
    }
}

$(document).ready(function(){
  var oForm = document.getElementById('parityTuningPage');
  initialiseParityTuning(oForm);
  presetParityTuning(oForm);
});

function checkCustom(fld) {
    var res = fld.value.split(" ");

    if ((res.length != 5) || (res[0] == "") ||(res[4] == "")) {
        swal({title: "_(Error in custom entry)_",
              text: "_(A crontab entry should have 5 space-separated values defining the minutes, hour, day of the month, month, day of the week)_.  _(Click on the crontab link to get more details on valid formats)_.",
              icon:"Error"});
		// Disable Apply button as saving invalid Custom entry will cause problems later
		document.getElementById('Apply').disabled = true;
		return false;
    } 
	return true;
}

function checkCustomOptions(form) {
	if (form.parityTuningFrequency.value == "1") {
		var fldPause = form.parityTuningPauseCustom;
		if (checkCustom(fldPause)) {
			var fldResume = form.parityTuningResumeCustom;
			if (checkCustom(fldResume)) {
				if (fldPause == fldResume) { 
					swal({title: "_(Pause and Resume times)_?",
						  text:"_(The Pause and Resume custom times cannot be identical)_.",
						  icon:"Error"});
					document.getElementById('Apply').disabled = true;
				}
			}
		}
	}
}


function checkNotifications (me) {
<?if (!isset($dynamixCfg['notify']['system']) || $dynamixCfg['notify']['system'] == "" ): ?>
    swal({title:"_(Notifications not enabled)_ ",
          text:"_('Before you can set this option to Yes you must first have enabled system notifications')_.",
          icon:"Info"});
    me.value="no";
<?endif;?>
}

function checkTimeRange(form) {
	var resumeTime = Number((form.parityTuningResumeHour.value) * 60) + Number(form.parityTuningResumeMinute.value);
	var pauseTime  = Number((form.parityTuningPauseHour.value) * 60)  + Number(form.parityTuningPauseMinute.value);
    var difference = pauseTime - resumeTime;
	if (difference == 0) {
		swal({title: "_(Pause and Resume times)_?",
			text:"_(The Pause and Resume times cannot be identical)_.",
			icon:"Error"});
		document.getElementById('Apply').disabled = true;
		return;
	}
    if ( difference < 0) difference += (24 * 60);
	if (difference > (12 * 60) ) {
		swal({title: "_(Pause and Resume times)_?",
			  text:"_(The Pause and Resume times would give an increment length of more than 12 hours which is unusual)_.  _(Are you sure you these are the right way around)_?",
			  icon:"Warning"});
	}
}

function DockerListSet(form) {
}

function checkHeatVeryLarge(value) {
	if (value > 20) {
	    swal({title: "_(Unusually large value)_?",
          text:"_(The value you have specified seems unusually large as it is not an absolute value but is relative to the value specified for the drives Temperature Warning level at the Unraid level)_",
          icon:"Warning"});
	}
}

function checkHeatLow(form) {
  var difference = form.parityTuningHeatLow.value - form.parityTuningHeatHigh.value;
  if (difference < 1 ) {
    swal({title: "_(Temperature Pause and Resume)_?",
          text:"_(The Resume value must be greater than the Pause one for the heat related Pause and Resume to work correctly as they are both subtracted from the disk temperature warning value when calculating the desired temperature)_",
          icon:"Warning"});
    }
}

function checkAutomaticMode (form) {
    if (form.parityTuningAutomatic.value == "1") {
        swal({title: "_(Do you really want this)_?",
              text: "_(Pausing an automatic parity check after an unclean shutdown extends the time before the you can be confident that parity is still valid so that recovering from a disabled disk is likely to work without data corruption or data loss)_.  _(Only use this option if you cannot afford the performance penalty of such checks occurring during prime time)_.",
              icon: "Warning"});
     }
}

function checkShutdown (form) {
    if (form.parityTuningShutdown.value == "1") {
        swal({title: "_(Do you really want this)_?",
              text: "_(No check is made to see if there is any other activity running on the server at the time the array operation completes)_. _(As a safety measure if you switch off this option while an array operation is running then the shutdown will be aborted)_.",
              icon: "Warning"});
     }
}

function checkLoggingMode (form) {
    switch (form.parityTuningLogging.value) {
    case "0":
            break;
    case "1":
            swal({title: "_(Do you really want Debug logging mode)_?",
            text:"_(Debug mode is intended to give users a feel for when the plugin is active)_ . _(Debug mode can generate frequent additional log entries in the syslog file so do not leave debug mode active if you are not interested in this information)_.",
            icon:"Warning"});
            break;

    case "2":
            swal({title: "_(Do you really want testing mode)_?",
            text:"_(Testing mode is normally only used by the plugin author or when gathering evidence of a suspected bug in the plugin)_ . _(Testing mode is very verbose and generates a lot of additional log entries so you do not want it enabled unless it is really necessary)_.",
            icon:"Warning"});
            break;
    } // end switch
}

function checkLoggingTarget (form) {
    switch (form.parityTuningLogTarget.value) {
    case "0":
            break;
    case "1":
	case "2":
            swal({title: "_(Do you really want to log to the flash drive)_?",
            text:"_(Logging to the flash drive can cause a lot additional writes thus potentially shortening its lifetime)_ . _(Do not leave this active if you are not interested in this information)_. _(CAUTION)_: _(At the moment there is no mechanism to stop this file from growing forever so it is up to you to manage this manually)_.",
            icon:"Warning"});
            break;
    } // end switch
}

function parityTuningHistory() {
	if(typeof openChanges === "function"){
	  // Unraid 6.11+ support
	  openChanges("parity_history", "_(Parity Operation History)_", "phistory");
	} else {
	  // legacy support (perhaps could be removed?)
	  openBox('/webGui/include/ParityHistory.php','Parity Operation History',600,900,false,'dd');
	}
}

function resetDefaults(form) {
	form.elements['#arg[1]'].value = 'defaults';
}

$(function() {
  if ( typeof caPluginUpdateCheck === "function" ) {
    caPluginUpdateCheck("parity.check.tuning.plg",{element:".pluginUpdate"});
  }
});


</script>

<div class="pluginUpdate"></div>

<form   markdown = "1" 
        id       = "parityTuningPage"
        method   = "POST" 
        action   = "/update.php" 
        target   = "progressFrame">
        
<input type="hidden" 
       name="#file"    
       value="<?=PARITY_TUNING_CFG_FILE?>">
<input type="hidden" 
       name="#command" 
       value="<?=PARITY_TUNING_PHP_FILE?>">
<input type="hidden"
       name="#arg[1]"
       value="config">


:parity_tune_explain_plug:
> This plugin does not initate array operations - instead it modifies/enhances the behaviour once the array opeation has started.
>
> The main purpose of this plugin is to allow you to limit array operations such as parity checks to running at times that will not inconvenience you.  You can specify indivdually whether increments should be used for each major type of array operation.
>
>Setting one of these options to **No** means you get the default system behavior of the operation running without a break to completion unless you manually stop/pause/cancel the operation.
>
>Setting one of these options to **Yes** specifies that the array operation should be run in increments spread over several days.
>
> As an example of what this plugin can do assume
>You have a parity check you have scheduled to start on the first of every month at midnight  
>* Your past experience has shown that if the parity check runs uninterrupted it takes 30 hours to complete.  
>* You set this plugin to use 3 hour increments starting at midnight and finishing at 3.00 A.M.  
>* The parity check will now actually take 10 days elapsed time (10 x 3 = 30) so the parity check will complete on 10th of the month.  
>* You have scheduled these increments to run starting at midnight and finishing at 3:00 A.M. when you know the system is not being used.  
>* You are not worried about this increased elapsed time and will welcome the increased system responsiveness during normal use.  
>* The rest of the month this plugin will do nothing as there is no active parity check in progress when the start time for an increment comes around.
>
>**NOTES:**  
>* The standard Unraid behaviour if the array is stopped while an array operation is incomplete is that the progress so far is lost and it can only be restarted from the beginning.  You can avoid this if you set the plugin option to resume array operations on next array start.  
>* If you have no parity disk or if the number of failed drives equals the number of disabled drives then a **Read Check** is carried out rather than a **Parity Check** to ensure that all the remaining drive can be read without error.
:end

<div id="parityTuningScheduledDisplay" markdown="1" style="display:none">
<?= sprintf(_('Use increments for %s %s'), _('scheduled'), ($parityTuningNoParity ? _('Read Check') : _('Parity Check'))); ?>:
: <select name="parityTuningScheduled" 
          size="1" class="narrow" 
          onChange="presetParityTuning(this.form)">
     <?=mk_option($parityTuningCfg['parityTuningScheduled'], "0", _("No")) . "\n"?>
     <?=mk_option($parityTuningCfg['parityTuningScheduled'], "1", _("Yes")) . "\n"?>
  </select>
 
:parity_tune_increments_plug:
>Scheduled Checks are those that you have configured to run at set times via Settings->Scheduler.
>
>Setting this option to **Yes** specifies that checks should be run in increments spread over several days.  Note that if you want to use the plugin to handle the array operation increments then you must **not** set the Cumnlative Parity Check option to **Yes** in the standard Unraid Parity Check settings.
>
>If you have set this to **No** then you get the default system behavior of checks running without a break to completion unless you manually stop/pause/cancel them.  
:end
</div> <!-- parityTuningScheduledDisplay -->

<div id="parityTuningManualDisplay" markdown="1" style="display:none">
<?= sprintf(_('Use increments for %s %s'), _('manual'), ($parityTuningNoParity ? _('Read Check') : _('Parity Check'))); ?>:
: <select name="parityTuningManual" 
          size="1" class="narrow"
          onChange="presetParityTuning(this.form)">
      <?=mk_option($parityTuningCfg['parityTuningManual'], "0", _("No")) . "\n"?>
      <?=mk_option($parityTuningCfg['parityTuningManual'], "1", _("Yes")) . "\n"?>
  </select>

:parity_tune_manual_plug:
> Manual Checks are those that you have initiated via the **Check** button the Main tab.
>
> Set this to **Yes** if you want checks that are started manually also be run in increments?
>
> It is quite likely that you will want such a check to run to completion without interruption and if so leave this option set to **No**.
> With this option set to **Yes** then if you manually start a check from the Main page and then manually Pause the check, this will result in the check being run in increments between the scheduled times until the check completes.
:end
</div> <!-- parityTuningManualDisplay -->

<div id="parityTuningAutomaticDisplay" markdown="1" style="display:none">
<?= sprintf(_('Use increments for %s %s'), _('automatic'), ($parityTuningNoParity ? _('Read Check') : _('Parity Check'))); ?>:
: <select name="parityTuningAutomatic" 
          size="1" class="narrow"
          onChange="presetParityTuning(this.form); checkAutomaticMode(this.form)">
      <?=mk_option($parityTuningCfg['parityTuningAutomatic'], "0", _("No")) . "\n"?>
      <?=mk_option($parityTuningCfg['parityTuningAutomatic'], "1", _("Yes")) . "\n"?>
  </select>

:parity_tune_automatic_plug:
> Automatic Checks are those that are initiated automatically by Unraid after an unclean shutdown.
>
> if the Unraid system is not shutdown cleanly then the next time the array is started Unraid will automatically start a check. This can happen for a wide variety of reasons ranging from power loss; hardware issues; and software issues. The automatic check is run because if there are any parity errors this can compromise the ability to recover from an array drive failure at a later date so you want to get back to having valid parity as soon as is practical.
> 
> If this option is set to **Yes** then the check will alays be allowed to run for a few minutes (as any errors after an unclean shutdown are most likely to be at the start of the disks as they were not unmounted cleanly.  Then if outside the time specified for running increments the check is put into a paused state. The  remainder of the check subsequently runs in increments according to the time slots specified for running increments.
:end
</div> <!-- parityTuningAutomaticDisplay -->


<div id="parityTuningReconDisplay" markdown="1" style="display:none">
_(Use increments for Parity-Sync/Data Rebuild operations)_:
: <select name="parityTuningRecon" 
          size="1" class="narrow"
          onchange="presetParityTuning(this.form); confirmReconYes(this.form)">
    <?=mk_option($parityTuningCfg['parityTuningRecon'], "0", _("No")) . "\n"?>
    <?=mk_option($parityTuningCfg['parityTuningRecon'], "1", _("Yes")) . "\n"?>
  </select>
	
:parity_tune_allops_plug:
> These are array the operations that involve building new parity or rebuilding a failed disk.
>
>This type of check will typically only be run if there is potentially some issue with your array and action is being taken to get it back into a protected state.
>
>**IMPORTANT**: Until this operation completes your array is not fully protected so it is assumed that most people will want this option left at **No**.
> Do not select **Yes** unless you are absolutely certain that is what you want.
:end
</div> <!-- parityTuningReconDisplay -->

<div id="parityTuningClearDisplay" markdown="1" style="display:none"> 
_(Use increments for Clear operations)_:
: <select name="parityTuningClear" 
          size="1" class="narrow"
          onchange="presetParityTuning(this.form); confirmClearYes(this.form)">
    <?=mk_option($parityTuningCfg['parityTuningClear'], "0", _("No")) . "\n"?>
    <?=mk_option($parityTuningCfg['parityTuningClear'], "1", _("Yes")) . "\n"?>
  </select>
		
:parity_tune_clear_plug:
> A disk Clear operation occurs when you add a new drive (that has not been pre-cleared using the Pre-Clear plugin) to an array that is parity protected. The Clear process writes zeroes to every sector on the new disk so that it can be added to the array without affecting the existing parity. Until the Clear operation has completed you are not able to format the disk in Unraid and start using it for storing data.
>
>Since until the Clear operation completes the disk will not be available for use it is likely that most people will want this option left at **No**. In addition, a Clear operation tends not to put much of a load on the system so is less likely to impact performance in normal daily use.
:end
</div> <!-- parityTuningClearDisplay -->

<div id="parityTuningIncrementDisplay" markdown="1" style="display:none"> 

_(Increment frequency)_:
: <select name="parityTuningFrequency" 
          size="1" class="narrow" 
          onchange="presetParityTuning(this.form)">
     <?=mk_option($parityTuningCfg['parityTuningFrequency'], "0", _("Daily")) . "\n"?>
	 <?=mk_option($parityTuningCfg['parityTuningFrequency'], "2", _("Weekly")) . "\n"?>
     <?=mk_option($parityTuningCfg['parityTuningFrequency'], "1", _("Custom")) . "\n"?>
  </select>

  
:parity_tune_frequency_plug:
> The frequency at which the increments should be run duraing an array opration.
>
> In normal operation it is expected that the **Daily** option will be the one that most users will want to use so this is the default. There is also a **Weekly** option for those who do infrequent checks.
>
> To support users looking for other frequencies there is the option to set up **Custom** schedules which will allow for more complicated schedules for the Pause and Resume times. When you use this option you are given the option to specify the time as used by the Linux <a href="https://en.wikipedia.org/wiki/Cron#Overview" target="_blank">crontab</a> utility.  
:end

<div id="parityTuningCustomResume" markdown="1" style="display:none">
_(Increment resume time)_:
: <span><input type="text"
         size="1" class="narrow"
         name="parityTuningResumeCustom"
         value="<?=$parityTuningCfg['parityTuningResumeCustom']?>"
         onblur="checkCustom(this)"><span>&nbsp; <?=sprintf(_('entry in %s format'),'<a href="https://en.wikipedia.org/wiki/Cron#Overview" target="_blank">crontab</a>')?></span>
</div> <!-- parityTuningCustomResume -->   

<div id="parityTuningResumeDisplay" markdown="1" style="display:none">
_(Increment resume time)_:
: <span><span id="parityTuningDayResume" markdown="1">
  <select name="parityTuningResumeDay" 
          size="1" class="narrow"
          onChange="checkTimeRange(this.form)">
	  <?=mk_option($parityTuningCfg['parityTuningResumeDay'] , 0, 'Sunday') . "\n"?>
      <?=mk_option($parityTuningCfg['parityTuningResumeDay'] , 1, 'Monday') . "\n"?>
      <?=mk_option($parityTuningCfg['parityTuningResumeDay'] , 2, 'Tuesday') . "\n"?>
      <?=mk_option($parityTuningCfg['parityTuningResumeDay'] , 3, 'Wednesday') . "\n"?>
      <?=mk_option($parityTuningCfg['parityTuningResumeDay'] , 4, 'Thursday') . "\n"?>
      <?=mk_option($parityTuningCfg['parityTuningResumeDay'] , 5, 'Friday') . "\n"?>
      <?=mk_option($parityTuningCfg['parityTuningResumeDay'] , 6, 'Saturday') . "\n"?>
  </select></span>
  <select name="parityTuningResumeHour" 
          size="1" class="narrow"
          onChange="checkTimeRange(this.form)">
<?for ($d=0; $d<=23; $d++):?>
         <?=mk_option($parityTuningCfg['parityTuningResumeHour'], strval($d), sprintf("%02d", $d)) . "\n"?>
<?endfor;?>
  </select>
  <select name="parityTuningResumeMinute" 
          size="1" class="narrow"
		  onChange="checkTimeRange(this.form)">
<?for ($d=0; $d<=55; $d+=5):?>
      <?=mk_option($parityTuningCfg['parityTuningResumeMinute'], strval($d), sprintf("%02d", $d)) . "\n"?>
<?endfor;?>
  </select> &nbsp;&nbsp;HH:MM</span>
</div> <!-- parityTuningResumeDisplay -->

:parity_tune_resume_plug:
> The time at which a paused parity check should be resumed.<br>If no parity check is currently paused when this time comes around then no action will be taken.
>
>Typically this time would be set to be the start of an idle period overnight. An appropriate value might be to use the same time that you have specified for a scheduled parity check to start.
>
>If the increment period has been set to **Custom** then the hours/minutes fields are hidden and you are instead given the option to set the time in <a href="https://en.wikipedia.org/wiki/Cron#Overview" target="_blank">crontab</a> format.
:end

<div id="parityTuningCustomPause" markdown="1" style="display:none">
_(Increment pause time)_:
: <span><input type="text"
          size="1" class="narrow"
          name="parityTuningPauseCustom"
          value="<?=$parityTuningCfg['parityTuningPauseCustom']?>"
          onblur="checkCustom(this)"><span>&nbsp; <?=sprintf(_('entry in %s format'),'<a href="https://en.wikipedia.org/wiki/Cron#Overview" target="_blank">crontab</a>')?></span> 
</div> <!-- parityTuningCustomPause -->

<div id="parityTuningPauseDisplay" markdown="1" style="display:none">
_(Increment pause time)_:
:  <span><span id="parityTuningDayPause" markdown="1">
  <select name="parityTuningPauseDay" 
          size="1" class="narrow"
          onChange="checkTimeRange(this.form)">
	  <?=mk_option($parityTuningCfg['parityTuningResumeDay'] , 0, 'Sunday') . "\n"?>
      <?=mk_option($parityTuningCfg['parityTuningResumeDay'] , 1, 'Monday') . "\n"?>
	  <?=mk_option($parityTuningCfg['parityTuningResumeDay'] , 2, 'Tuesday') . "\n"?>
      <?=mk_option($parityTuningCfg['parityTuningResumeDay'] , 3, 'Wednesday') . "\n"?>
      <?=mk_option($parityTuningCfg['parityTuningResumeDay'] , 4, 'Thursday') . "\n"?>
      <?=mk_option($parityTuningCfg['parityTuningResumeDay'] , 5, 'Friday') . "\n"?>
      <?=mk_option($parityTuningCfg['parityTuningResumeDay'] , 6, 'Saturday') . "\n"?>
  </select></span>
  <select name="parityTuningPauseHour" 
          size="1" class="narrow"
          onChange="checkTimeRange(this.form)">
      <?for ($d=0; $d<=23; $d++){?>
        <?=mk_option($parityTuningCfg['parityTuningPauseHour'], strval($d), sprintf("%02d", $d)) . "\n"?>
      <?}?>
    </select>
    <select name="parityTuningPauseMinute"
            size="1" class="narrow"
			onChange="checkTimeRange(this.form)">
<?for ($d=0; $d<=55; $d+=5):?>
          <?=mk_option($parityTuningCfg['parityTuningPauseMinute'], strval($d), sprintf("%02d", $d)) . "\n"?>
<?endfor;?>
    </select> &nbsp;&nbsp;HH:MM</span>
</div> <!-- parityTuningPauseDisplay -->

:parity_tune_pause_plug:
> The time at which a running parity check should be paused. Typically, this would be set to be a time when you want other activity to not be affected by a running parity check.
>If no parity check is actively running when this time comes around then no action will be.
>
>Normally you want to make sure that this time is set to be after the time that you schedule regular parity checks to run. The first increment will then be from when the regular parity check is scheduled to start up to the time you have specified for the increment to end.
>
>If the increment period has been set to **Custom** then the hours/minutes fields are hidden and you are instead given the option to set the time in <a href="https://en.wikipedia.org/wiki/Cron#Overview" target="_blank">crontab</a> format.
>
>You also want to make sure that the time allocated to running increments is sufficient to expect the parity check to run to completion before the next check is scheduled to start. Since most people only schedule parity checks to run infrequently (e.g. Monthly or Quarterly) then this is unlikely to be an issue but it is something to take into consideration.  
:end

_(Send notifications for Pause or Resume of increments)_:
: <select name="parityTuningNotify" 
          size="1" class="narrow"
          onchange="presetParityTuning(this.form); checkNotifications(this)">
    <?=mk_option($parityTuningCfg['parityTuningNotify'], "0", _("No")) . "\n"?>
    <?=mk_option($parityTuningCfg['parityTuningNotify'], "1", _("Yes")) . "\n"?>
  </select>

:parity_tune_notify_plug:
> This option is only relevant if you have enabled the Settings->System Notifications option (highly recommended).
>
> Setting this option to <strong>Yes</strong> means that you will be sent a notification every time the plugin Pauses or Resumes an increment during an array operation.
>
>If you would rather not get such notifications then leave this option set to **No**.
>
>Notifications that are deemed to be just informative are sent as a **Normal** (green) category message to the targets specified under *<a href="Settings/Notifications">Settings->Notification Settings</a>*, although more important ones will use the **Warning** (orange) or *Error** (red) type notifications where it seems appropriate.
:end
</div> <!-- parityTuningIncrementDisplay -->


_(Resume array operations on next array start)_:
: <select name="parityTuningRestart" 
          size="1" class="narrow"
          onchange="presetParityTuning(this.form)">
    <?=mk_option($parityTuningCfg['parityTuningRestart'], "0", _("No")) . "\n"?>
    <?=mk_option($parityTuningCfg['parityTuningRestart'], "1", _("Yes")) . "\n"?>
  </select>
  
:parity_tune_restart_plug:
> Unraid will normally abandon a parity check if the system is shutdown, rebooted, or the array is stopped (with the only option being to restart the parity check from the beginning).  
> Other array operations will be restarted from the beginning.
> Setting this option allows parity checks to be restarted by this plugin from the point they had reached
> as long as the following criteria are met:  
>* The array was shutdown tidily  
>* The user must not have made any changes to the array configuration.
>
>As long as these criteria are met then when the array is next started the operation is resumed from the point previously reached.
>
>**NOTES:**  
>* If the array operation was within the time set for a scheduled increment to be running then on restarting the array operation it will be set to be paused if now outside the time set for running increments.  
>* If the array operation was manually paused then the restarted array operation will also be paused.
>
:end

_(Pause array operations while mover running)_:
: <select name="parityTuningMover" 
          size="1" class="narrow"
          onchange="presetParityTuning(this.form)">
    <?=mk_option($parityTuningCfg['parityTuningMover'], "1", _("Yes")) . "\n"?>
    <?=mk_option($parityTuningCfg['parityTuningMover'], "0", _("No")) . "\n"?>
  </select>
  
:parity_tune_mover_plug:
>Pause an array operation (Parity Check, Read-Check, Parity-Sync,. Disk Rebuild, Disk Clear) if mover is running. An array operation being run in parallel to mover adversely affects the performance due to contention on the disk drives so it is more efficient to not have them running at the same time.
>
> This setting takes effect even if you are not using any of the options to run an array operation in increments.
> 
> If you are running the array operation type in increments then the resume will only happen after mover finishes if you are still within the time windows for the increment.
:end

<div id="parityTuningBackupDisplay" markdown="1" style="display:none">
_(Pause array operations while appdata backup or restore running)_:
: <select name="parityTuningBackup"
          size="1" class="narrow" 
          onchange="presetParityTuning(this.form)">
    <?=mk_option($parityTuningCfg['parityTuningBackup'], "1", _("Yes")) . "\n"?>
    <?=mk_option($parityTuningCfg['parityTuningBackup'], "0", _("No")) . "\n"?>
  </select> 

:parity_tune_backup_plug:
>Pause an array operation (Parity Check, Read-Check, Parity-Sync,. Disk Rebuild, Disk Clear) if the CA Appdata or Appdata Backup plugins are running a backup or restore of docker container data.  An array operation being run in parallel to the backup or restore adversely affects the performance due to contention on the disk drives so it is more efficient to not have them running at the same time.
>
> This setting takes effect even if you are not using any of the options to run an array operation in increments.
>
> If you are running the array operation type in increments then the resume will only happen after the backup or restore finishes if you are still within the time windows for the increment.
:end
</div> <!-- parityTuningBackupDisplay -->

<div id="parityTuningBackgroundDisplay" markdown="1" style="display:none">
<?= sprintf ($parityTuningNoBackup?"_(Send notifications for mover running)_":"_(Send notifications for mover or backup running)_")?>:
: <select name="parityTuningBackground" 
          size="1" class="narrow"
          onchange="presetParityTuning(this.form); checkNotifications(this)">
    <?=mk_option($parityTuningCfg['parityTuningBackground'], "0", _("No")) . "\n"?>
    <?=mk_option($parityTuningCfg['parityTuningBackground'], "1", _("Yes")) . "\n"?>
  </select>

:parity_tune_background_plug:
> This option is only relevant if you have enabled the Settings->System Notifications option (higly recommended).
>
> Setting this option to <strong>Yes</strong> means that you will be sent a notification every
> time a background task such as Appdata Backup or mover starts or completes. If this option
> is set then the notification is sent whenever these operations start or stop while an array
> operation is active even if you have not set the operation to be paused or resume while
> such tasks are running. This can be helpful to help see when the performance of the array
> operation is likely to be interacting badly with the background task in terms of performance.
>
>If you would rather not get such notifications then leave this option set to **No**.
>The notification is sent as a **Notice** category message to the target(s) specified under *<a href="Settings/Notifications">Settings->Notification Settings</a>*.
:end
</div> <!-- parityTuningBackgroundDisplay -->

<div id="parityTuningDockerDisplay" markdown="1" display="none">

_(Pause Docker Containers while array operations running)_:
: <select name="parityTuningDocker" 
          size="1" class="narrow"
          onchange="presetParityTuning(this.form)"> 
    <?=mk_option($parityTuningCfg['parityTuningDocker'], "1", _("Yes")) . "\n"?>
    <?=mk_option($parityTuningCfg['parityTuningDocker'], "0", _("No")) . "\n"?>
  </select>

:parity_tune_docker_plug:
>Setting this option allows you to pause specified docker containers while a parity operation is running.
>
>You only want to consider doing this for containers that would be accessing the array during the parity operation and which would thus impact performance.
:end


<div id="parityTuningContainersDisplay" markdown="1" display="none">

_(Docker containers to be paused)_:
: <select multiple
	  name="parityTuningContainers"
      size="1" class="narrow"
      onchange="presetParityTuning(this.form)"
      onclick="DockerListSet(this.form)"> 
	<? //if ($parityTuningDockerEnabled) {
		//   $parityTuningContainers = $parityTuningCfg['parityTuningContainers'];
		//   parityTuningLoggerTesting("parityTuningContainers: $parityTuningContainers");
		//   $parityTuningContainersInstalled = dockerContainerList();
		//   if ($parityTuningContainersInstalled != false) {
		//	  foreach ($parityTuningContainersInstalled as $container) { 
		//		 $name = $container['Names'];
		//		 parityTuningLoggerTesting("adding option for container: $name");
		//		 echo mk_option_check($parityTuningContainers, $name, $name) . "\n";
		//	  }
		//	}
		//}
	?>
  </select>
  
:parity_tune_dockerlist_plug:
>A list of docker containers to be paused.
>
>The containers will only actually be paused if they have running status at the time the parity operation is initiated (or resumed).  They will be put back into a running state any time the parity operation is paused or if it completes.
:end

</div></div>


_(Pause and Resume array operations if disks overheat)_:
: <select name="parityTuningHeat"
          size="1" class="narrow"
          onchange="presetParityTuning(this.form)"> 
    <?=mk_option($parityTuningCfg['parityTuningHeat'], "1", _("Yes")) . "\n"?>
    <?=mk_option($parityTuningCfg['parityTuningHeat'], "0", _("No")) . "\n"?>
  </select>

:parity_tune_hot_plug:
>Pause an array operation(Parity Check, Parity-Sync/Disk Rebuild, disk Clear)if the disk temperatures exceeds the limits you have set. 
>
>The temperatures are checked against the thresholds set for the Warning disk temperature levels. If a threshold has been defined for an individual drive (accessed by clicking on the drive in the Main tab) then this is the value used. If not the global setting (set via *Settings->Display Settings*) will be used. It is assumed that normally you would want the array operation to be paused before the value set at the Unraid level as the Warning Threshold.
>
>A much better solution is to improve the cooling in your case so that the disks never overheat. In practice this may not always prove practical.
>
>If the array operation was paused while running an increment then it will not be resumed outside the time allotted for the increment. If the array operation was initiated for any other reason then the Pause/Resume behavior on temperature is always active.
:end

<div id="parityTuningHeatDisplay" markdown="1" style="display:none">

_(Pause an array operation at)_:
: <span><input name="parityTuningHeatHigh" 
         size="1" class="narrow"
         type="text"        
		 onchange="presetParityTuning(this.form); checkHeatVeryLarge(this.form.parityTuningHeatHigh.value),checkHeatLow(this.form)"
         value="<?=$parityTuningCfg['parityTuningHeatHigh']?>">&deg;<?= $parityTuningTempUnit ?> _(below warning disk temperature threshold)_</span>
		 
:parity_tune_warn_plug:
> This value indicates how close to the value set for the Warning Disk Temperature Threshold a disks temperature is allowed to reach before a **pause** of a running array operation is triggered. If an explicit threshold has been defined for an individual drive then this is the value used. If not the global setting will be used.
>
> You normally want a small positive value to trigger the pause before Unraid gets around to sending you a notification that the temperature warning threshold has been reached for a disk.
>
>If there is no active array operation then no action will be taken even if disk temperatures exceed the specified threshold.
>
> If there is no running array operation then no action will be taken.
:end


_(Resume an array operation at)_:
: <span><input name="parityTuningHeatLow" 
         size="1" class="narrow"
         type="text"	
		 onchange="presetParityTuning(this.form); checkHeatVeryLarge(this.form.parityTuningHeatLow.value),checkHeatLow(this.form)"
         value="<?=$parityTuningCfg['parityTuningHeatLow']?>">&deg;<?= $parityTuningTempUnit ?> _(below warning disk temperature threshold)_</span>

:parity_tune_low_plug:
> This value indicates how much below the Warning temperature threshold of a drive must reach before a **resume** of an array operation is considered. If using increments has been set for the type of operation being performed then the time must be within the increments window or the resume wil be deferred until that window is rezched.
>
>You need to get a good balance between array operations being resumed too soon (and thus quickly reaching the level to initiate another pause) and wasting a lot of time.
>
>If a disk ever gets spun down the temperature is not readily available so it will be assumed that this criteria has been met
>
>If there is no paused array operation then no action will be taken. 
:end


_(Send notifications for temperature related Pause or Resume)_:
: <select name="parityTuningHeatNotify" 
          size="1" class="narrow"
          onchange="presetParityTuning(this.form); checkNotifications(this)"> 
    <?=mk_option($parityTuningCfg['parityTuningHeatNotify'], "0", _("No")) . "\n"?>
    <?=mk_option($parityTuningCfg['parityTuningHeatNotify'], "1", _("Yes")) . "\n"?>
  </select>

:parity_tune_temp_notify_plug:
> Setting this option to **Yes** means that you will be sent a notification every time the plugin Pauses or Resumes an array operation due to the temperature of your drives.<br>If you would rather not get such notifications then leave this option set to **No**. The notification is sent as a **Notice** category message to the target(s) specified under *<a href="Settings/Notifications">Settings->Notification Settings</a>*.
:end

</div>

_(High disk temperatures can shutdown server)_:
: <select name="parityTuningHeatShutdown" 
          size="1" class="narrow"
          onchange="presetParityTuning(this.form)">
    <?=mk_option($parityTuningCfg['parityTuningHeatShutdown'], "0", _("No")) . "\n"?>
    <?=mk_option($parityTuningCfg['parityTuningHeatShutdown'], "1", _("Yes")) . "\n"?>
  </select>

:parity_tune_shutdown_plug:
> If set to **Yes** then automatically start a tidy shutdown of the server if any disk in the array or pools reach the defined temperature threshold.
> The temperatures are checked against the thresholds set for the **Critical** disk temperature levels. If a Critical temperature has been defined for an individual drive (accessed by clicking on the drive in the Main tab) then this is the value used. If not the global setting (*<a href="Settings/DisplaySettings">Settings->Display Settings</a>) will be used.
>
>This option is intended to be triggered if for some reason the system's cooling system is insufficient or if it has failed in some way. The idea is that you want to do a tidy shutdown before the disks become damaged due to overheating. The shutdown that is triggered is functionally the same as would be the case of pressing the Shutdown button on the Main page of the Unraid GUI. If notifications are enabled then you are sent one to indicate that this has happened.
>
>When the server is started up again after such a shutdown then when the array is started you will be notified that a temperature related shutdown happened in case you were not aware of the reason.
>
>**CAUTION:** If the array is stopped while an array operation is incomplete then the default Unraid behaviour is that progress so far is lost and it can only be restarted from the beginning.  
>
>If you have enabled the restart option in this plugin *and* the shutdown is a tidy shutdown) then an attempt will made to restart the array operation from the point it had previously reached.
:end

<div id="parityTuningCriticalDisplay" markdown="1" style="display:none">

_(Shutdown server at)_:
: <span><input name="parityTuningHeatCritical" 
           size="1" class="narrow"
           type="text"
           value="<?=$parityTuningCfg['parityTuningHeatCritical']?>">&deg;<?= $parityTuningTempUnit ?> _(below critical disk temperature threshold)_</span>
		   
:parity_tune_critical_plug:
> This value indicates how close to the value set for the Critical Disk Temperature Threshold the temperature is of a disk is allowed to reach before a shutdown of the server is triggered.
> You may want a small positive value to trigger the pause before Unraid gets around to sending you a notification that the temperature critical threshold has been reached for a disk.
>
>If an explicit threshold has been defined for an individual drive then this is the value used.  If not the global setting will be used.
:end

</div> <!-- parityTuningCriticalDisplay -->

_(Shutdown server when array operation completes)_:
: <select name="parityTuningShutdown" 
          size="1" class="narrow"
          onchange="presetParityTuning(this.form); checkShutdown(this.form)">
    <?=mk_option($parityTuningCfg['parityTuningShutdown'], "0", _("No")) . "\n"?>
    <?=mk_option($parityTuningCfg['parityTuningShutdown'], "1", _("Yes")) . "\n"?>
  </select>
  
:parity_tune_complete_plug:
> If set to **Yes** then automatically start a tidy shutdown of the server when the current array operation completes.
>
> This option is only likely to be of use on a server that is powered off most of the time as it is used for something like backup purposes. The idea is that you can initiate the array operation (either manually or via a schedule) and then leave the server to power itself down without having to know how long the array operation will take to complete.
>
> When it is detected that you have this option set and an array operation is in progress  then a notification is raised that the shutdown will happen. As a safety measure if this option is initially set at the start of the array operation, but is unset before it finishes then the shutdown will be aborted.
>
>**CAUTION:** No check is made to see if there is any other activity running on the server at the time the array operation completes before the shutdown is initiated
:end
  
<!-- &nbsp; -->

_(Parity Check Tuning logging)_:
: <span><select name="parityTuningLogging" 
          size="1" class="narrow"
          onchange="presetParityTuning(this.form); checkLoggingMode(this.form)">
    <?=mk_option($parityTuningCfg['parityTuningLogging'], PARITY_TUNING_LOGGING_BASIC, _("Basic")) . "\n"?>
    <?=mk_option($parityTuningCfg['parityTuningLogging'], PARITY_TUNING_LOGGING_DEBUG, _("Debug")) . "\n"?>
    <?=mk_option($parityTuningCfg['parityTuningLogging'], PARITY_TUNING_LOGGING_TESTING, _("Testing")) . "\n"?>
  </select>  <select name="parityTuningLogTarget"
          size="1" class="narrow"
		  onchange="presetParityTuning(this.form); checkLoggingTarget(this.form)">
		  <?=mk_option($parityTuningCfg['parityTuningLogTarget'], PARITY_TUNING_LOGGING_SYSLOG, _("Syslog only")) . "\n"?>
          <?=mk_option($parityTuningCfg['parityTuningLogTarget'], PARITY_TUNING_LOGGING_BOTH, _("Syslog and Flash")) . "\n"?>
          <?=mk_option($parityTuningCfg['parityTuningLogTarget'], PARITY_TUNING_LOGGING_FLASH, _("Flash only")) . "\n"?>
	  </select></span>
	  
:parity_tune_logging_plug:
> Control the level of detail in entries. The level of detail can be increased to help with debugging any problems using this plugin might encounter.
>
>Messages by this plugin are identified by the fact that they are shown as coming from  
>* **Parity Check Tuning**  
>* **Parity Problems Assistant**  
>depending on which part of the plugin generated the messages
>
>With the **Basic** option set these will only be a small number of messages indicating that this plugin has taken some action or an possible error condition has been detected.  This will be what most users want in normal operation.
>
>Setting this option to **Debug** will result in additional entries being written to the syslog that give more information on what is happening when this plugin is running. They show how some of the internal operation of how the plugin is functioning. These additional entries are identified by the fact that they will have the word **DEBUG** added to the start of messages. Some users (particularly those who have not used this plugin before) may like to use it to see more detail on how this plugin operates, but it is not expected that this option will be left enabled in normal running.
>
>Finally there is an additional setting of **Testing** that is only intended for use by the developer but is left here for convenience. It will write even more verbose messages to the syslog but these are not likely to be interesting (or even meaningful) to the average user.  These messages will have the word **TESTING** added to the start of messages. You should only run this level of logging if you have been asked to as it can quickly fill up your syslog if you are not careful.
>
>Feedback is welcome as to whether it is worth introducing any intermediate option that outputs information type messages on the plugins activity, while omitting some of the lower level detail that is aimed at diagnosing any problems that might be encountered while the plugin is running. 
>
>If you have Testing mode set for the logging then you can choose where you want log messages to be recorded. The default is the standard system syslog and this is the only option allowed in Basic mode. The syslog is held in RAM so does not cause excessive writes to the flash drive. 
>To facilitate with debugging problems then in Testing mode you can log the messages to the flash drive either instead of the syslog or in addition to the syslog. The resulting parityTuning.log file will be stored in the plugin's folder on the flash drive and providing this file to the developer will help with diagnosing any unexpected behaviour you encounter.
:end

&nbsp; <!-- Dummy label to get button alignment -->

: <input type="submit" 
        name="#apply" 
        value="_(Apply)_" 
        id="Apply"
		onclick="checkCustomOptions(this.form)">
<input type="button" 
        id="DONE" 
        value="_(Done)_"
        onclick="done()">
<input type="submit" 
     id="Defaults" 
     value="_(Defaults)_"
     onclick="resetDefaults(this.form)">

:parity_tune_defaults_plug:
> The **Apply** button will save the currently displayed values of the settings.

> The **Done** button exits the settings page.

> The **Defaults** button will reset the plugin settings to the default values that are used when the plugin is first installed and immediately save these as the current settings.
> You can now make changes to these settings to suit your system and hit the Apply button to save them.
:end
 
<?if (file_exists("/boot/config/parity-checks.log")):?>
&nbsp; <!-- Dummy label to get button alignment -->
: <span class="buttons-spaced">
    <input type="button" 
       id="showHistory" 
       value="_(History)_"
       onclick="parityTuningHistory()">_(Click to show Array Operations history)_
  </span>

:parity_tune_history_plug:
> The **History** button will display the current history of parity checks. 
> It is identical in function to using the **History** button on the **Main** tab.
:end
<?endif;?>

<a style="float:right" href='https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&amp;hosted_button_id=U2FVNHSETTNRG' target="_blank"><img src="https://www.paypalobjects.com/en_US/i/btn/btn_donateCC_LG.gif" title="_(Donate to plugin author)_"></a>
<span style="float:right"><?=$parityTuningVersion?></span>

</form>
<?endif?>